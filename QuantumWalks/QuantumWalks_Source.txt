A continuación se presenta el código fuente completo de la librería QuantumWalks. Úsalo como referencia absoluta para nombres de funciones y estructura.

=== FILENAME: QuantumWalks/Kernel/init.m ===
(* QuantumWalks Initialization File 
   Se ejecuta automáticamente al cargar << QuantumWalks` 
*)

Block[{$ContextPath},
    Module[{rootPath},
        (* 1. Obtener la ruta raíz del paquete *)
        (* Kernel/init.m -> Subir dos niveles -> Raíz del paquete *)
        rootPath = DirectoryName[DirectoryName[$InputFileName]];
        
        (* 2. Cargar el módulo base (1D / General) *)
        Get[FileNameJoin[{rootPath, "DQWL.wl"}]];

        (* 3. Cargar librerías de Billares (Respetando CamelCase) *)
        
        (* A. Cargar Common.wl primero (lógica base) *)
        (* Nota: Carpeta "Billiards" y archivo "Common.wl" *)
        Get[FileNameJoin[{rootPath, "Billiards", "Common.wl"}]];
        
        (* B. Cargar Bunimovich.wl (depende de Common) *)
        (* Nota: Carpeta "Billiards" y archivo "Bunimovich.wl" *)
        Get[FileNameJoin[{rootPath, "Billiards", "Bunimovich.wl"}]];
        
        (* Futuros billares: *)
        (* Get[FileNameJoin[{rootPath, "Billiards", "Rectangle.wl"}]]; *)
    ]
];

=== FILENAME: QuantumWalks/Billiards/Common.wl ===
BeginPackage["QuantumWalks`Billiards`Common`"];

(* Símbolos exportados genéricos *)
BuildGridShiftOperators::usage = "BuildGridShiftOperators[gridData] construye los operadores de desplazamiento (Wm, Wn) para cualquier geometría de rejilla 2D definida en gridData.";
GenericSU2Coin::usage = "GenericSU2Coin[\[Alpha], dim] devuelve el operador moneda SU(2) extendido al espacio de Hilbert de dimensión dim.";

Begin["`Private`"];

(* --- Construcción de Operadores (Genérico para cualquier Rejilla) --- *)
BuildGridShiftOperators[gridData_Association] := Module[
    {
        coords, map, dim,
        indicesUp, indicesDown,
        destUp, destDown,
        rulesWm, rulesWn  (* CORREGIDO: Eliminados guiones bajos *)
    },
    
    coords = gridData["Coords"];
    map = gridData["Mapping"];
    dim = gridData["Dimension"];

    (* Estructura del Espacio de Hilbert: Índice = 2*(map[{m,n}] - 1) + spin + 1 *)
    indicesUp = 2 * (Range[dim] - 1) + 1;   (* |m,n, U> *)
    indicesDown = indicesUp + 1;            (* |m,n, D> *)

    (* --- Wm (Horizontal) --- *)
    destUp = map /@ (coords + ConstantArray[{1, 0}, dim]);
    destDown = map /@ (coords - ConstantArray[{1, 0}, dim]);
    
    rulesWm = Flatten[{
        (* Spin UP: Si choca (Missing), refleja. Si no, avanza. *)
        MapThread[If[MissingQ[#2], {#1, #1 + 1} -> 1, {#1, 2*(#2 - 1) + 1} -> 1] &, {indicesUp, destUp}],
        (* Spin DOWN *)
        MapThread[If[MissingQ[#2], {#1, #1 - 1} -> 1, {#1, 2*(#2 - 1) + 2} -> 1] &, {indicesDown, destDown}]
    }];

    (* --- Wn (Vertical) --- *)
    destUp = map /@ (coords + ConstantArray[{0, 1}, dim]);
    destDown = map /@ (coords - ConstantArray[{0, 1}, dim]);

    rulesWn = Flatten[{
        (* Spin UP *)
        MapThread[If[MissingQ[#2], {#1, #1 + 1} -> 1, {#1, 2*(#2 - 1) + 1} -> 1] &, {indicesUp, destUp}],
        (* Spin DOWN *)
        MapThread[If[MissingQ[#2], {#1, #1 - 1} -> 1, {#1, 2*(#2 - 1) + 2} -> 1] &, {indicesDown, destDown}]
    }];

    {
        SparseArray[rulesWm, {2 dim, 2 dim}],
        SparseArray[rulesWn, {2 dim, 2 dim}]
    }
]

(* --- Moneda Genérica --- *)
GenericSU2Coin[\[Alpha]_, gridDim_Integer] := 
    KroneckerProduct[
        IdentityMatrix[gridDim, SparseArray], 
        SparseArray[{{Cos[\[Alpha]], Sin[\[Alpha]]}, {-Sin[\[Alpha]], Cos[\[Alpha]]}}]
    ]

End[];
EndPackage[];

=== FILENAME: QuantumWalks/Billiards/Bunimovich.wl ===
BeginPackage["QuantumWalks`Billiards`Bunimovich`", {"QuantumWalks`Billiards`Common`"}];

(* Símbolos específicos del Estadio *)
GenerateStadiumBasis::usage = "GenerateStadiumBasis[xc, nu] genera la base de posiciones y la asociación de búsqueda para el estadio.";

(* Wrappers *)
BuildShiftOperators::usage = "Alias de BuildGridShiftOperators para el contexto Bunimovich.";
StadiumCoin::usage = "Alias de GenericSU2Coin para el contexto Bunimovich.";

Begin["`Private`"];

(* --- 1. Geometría Específica del Estadio --- *)

(* Eqs A7 y A8 del paper *)
BoundaryF[m_, mc_, nu_] := If[m < mc, nu, Round[Sqrt[nu^2 - (m - mc)^2]]];
BoundaryW[n_, mc_, nu_] := mc + Round[Sqrt[nu^2 - n^2]];

GenerateStadiumBasis[xc_Integer, nu_Integer] := Module[
    {coords, stateToIndex},
    
    (* Generación optimizada de coordenadas *)
    coords = Select[
        Flatten[Table[{m, n}, {m, 0, 2 xc + nu}, {n, 0, nu}], 1],
        Function[pos, 
            And[
                0 <= pos[[1]] <= BoundaryW[pos[[2]], xc, nu],
                0 <= pos[[2]] <= BoundaryF[pos[[1]], xc, nu]
            ]
        ]
    ];

    (* Mapeo O(1) *)
    stateToIndex = AssociationThread[coords -> Range[Length[coords]]];

    <|
        "Coords" -> coords,
        "Mapping" -> stateToIndex,
        "Dimension" -> Length[coords],
        "Params" -> {xc, nu},
        "Type" -> "Bunimovich"
    |>
]

(* --- 2. Enlaces a Common (Wrappers) --- *)

(* Simplemente pasamos los datos a la función genérica optimizada de Common *)
(* Nota: gridData_ es correcto aquí porque es un patrón de argumento *)
BuildShiftOperators[gridData_] := BuildGridShiftOperators[gridData];

(* Lo mismo para la moneda *)
StadiumCoin[\[Alpha]_, dim_] := GenericSU2Coin[\[Alpha], dim];

End[];
EndPackage[];

=== FILENAME: QuantumWalks/DQWL.wl ===
(* If ForScience paclet not installed, install it. See https://github.com/MMA-ForScience/ForScience *)
If[Length[PacletFind["ForScience"]]==0, PacletInstall[FileNameJoin[{DirectoryName[$InputFileName], "ForScience-0.88.45.paclet"}]]];
BeginPackage["QuantumWalks`"]
(* For nice formatting of usage messages, see https://github.com/MMA-ForScience/ForScience *)
<<ForScience`;
ClearAll[
  Shift, Coin, DTQWStep, DTQW, PositionProbabilityDistribution
]
Usage definitions
DTQW
Shift::usage = FormatUsage["Shift[t] yields a sparse array of the Shift operator for a 1D DTQW in an infinite line at time ```t```."];
Coin::usage = FormatUsage["Coin[t] yields a sparse array of the Haddamard Coin operator for a 1D DTQW in an infinite line at time ```t```.
Coin[t,C] yields a sparse array of the Coin operator ```C``` for a 1D DTQW in an infinite line at time ```t```."];
DTQWStep::usage = FormatUsage["DTQWStep[t] yields the unitary matrix of a Haddamard 1D DTQW in an infinite line at time ```t```.
DTQWStep[t,C] yields the unitary matrix of a 1D DTQW in an infinite line, using coin ```C```, at time ```t```."];
DTQW::usage = FormatUsage["DTQW[\[Psi]_0,t] yields the state at time ```t``` of a 1D Haddamard DTQW in an infinite line with initial state ```\[Psi]_0```.
DTQW[\[Psi]_0,t,C] yields the state at time ```t``` of a 1D DTQW in an infinite line, with coin ```C```, with initial state ```\[Psi]_0```."];
PositionProbabilityDistribution::usage = FormatUsage["PositionProbabilityDistribution[\[Psi],t] yields the position probability distribution of the state ```\[Psi]``` of a 1D DTQW at time ```t```."];
ExpValPosition::usage = FormatUsage["ExpValPosition[\[Psi],t] returns the expected value of position for the state \[Psi] of a 1D DTQW at time ```t```."];
Parrondo's paradox
L::usage = FormatUsage[
	"LoosingStrategy[\[Theta], \[Theta]_a, \[Theta]_b] returns the loosing inequality."
];
W::usage = FormatUsage[
	"WinningStrategy[\[Theta], \[Theta]_a, \[Theta]_b] returns the winning inequality."
];
CriticalAngle::usage = FormatUsage[
	"CriticalAngle[avgPos] takes a list of sublists ```avgPos```, where each subslit \
	is of the form '''{\[Theta],\[LeftAngleBracket]x(\[Theta])\[RightAngleBracket]}''', and returns the value '''\[Theta]''' such that \
	'''\[LeftAngleBracket]x(\[Theta])\[RightAngleBracket]''' is the closest to zero of all sublsists."
];
Routine definitions
Begin["`Private`"]
DTQW
Shift[t_] := Module[{},
  (* Check if t is an integer *)
  If[! IntegerQ[t], 
   Return[Message[Shift::intarg, t]]];
  
  (* Proceed with the original implementation *)
  SparseArray[
    Join[
      Table[{i, i + 2}, {i, Range[2, # - 2, 2]}], 
      Table[{i, i - 2}, {i, Range[3, #, 2]}]
    ] -> 1., {#, #}] &[2*(2*t + 1)]
]

(* Define a message for non-integer argument *)
Shift::intarg = "Argument `1` must be an integer (time).";
Coin::intarg = "Argument `1` must be an integer (time).";
Coin::matarg = "Argument `1` must be a matrix (coin argument).";

Coin[t_] := Module[{},
  (* Check if t is an integer *)
  If[! IntegerQ[t], 
   Return[Message[Coin::intarg, t]]];
  
  (* Proceed with the original implementation *)
  KroneckerProduct[IdentityMatrix[2 t + 1, SparseArray], SparseArray[FourierMatrix[2]]]
]

Coin[t_, c_] := Module[{},
  (* Check if t is an integer *)
  If[! IntegerQ[t], 
   Return[Message[Coin::intarg, t]]];
  
  (* Check if c is a matrix *)
  If[! MatrixQ[c], 
   Return[Message[Coin::matarg, c]]];
  
  (* Proceed with the original implementation *)
  KroneckerProduct[IdentityMatrix[2 t + 1, SparseArray], c]
]
DTQWStep[t_] := Shift[t] . Coin[t]
DTQWStep[t_, c_] := Shift[t] . Coin[t, c]
DTQWStep[t_, c_, psi_] := Chop[DTQWStep[t, c] . ArrayPad[psi, 2]]
DTQW[psi0_, t_] := Module[{psi},
  psi = ArrayPad[psi0, 2];
  Do[psi = ArrayPad[Chop[DTQWStep[i] . psi], 2], {i, t}];
  psi
]

DTQW[psi0_, t_, c_] := Module[{psi},
  psi = ArrayPad[psi0, 2];
  Do[psi = ArrayPad[Chop[DTQWStep[i, c] . psi], 2], {i, t}];
  psi
]
PositionProbabilityDistribution[psi_, tmax_] := Chop[
  Total[Abs[psi[[# ;; # + 1]]]^2] & /@ Range[1, 2*(2*tmax + 3), 2]
]
ExpValPosition[\[Psi]_,t_]:=PositionProbabilityDistribution[\[Psi],t] . Range[-t-1,t+1]
Parrondo's paradox
L[\[Theta]_,\[Theta]a_,\[Theta]b_]:=\[Theta]a<=Mod[\[Theta],2.Pi]<=\[Theta]b
W[\[Theta]_,\[Theta]a_,\[Theta]b_]:=Mod[\[Theta],2.Pi]<=\[Theta]a||Mod[\[Theta],2.Pi]>=\[Theta]b
CriticalAngle[avgPos_] := 
	SortBy[
		Discard[avgPos, Round[#[[1]], 10.^-6] == Round[2Pi, 10.^-6] || Round[#[[1]], 10.^-6] == 0. &],
		Abs[#[[2]]]&
	][[1, 1]]
End[]
EndPackage[]
